local Fluent = loadstring(game:HttpGet("https://raw.githubusercontent.com/discoart/FluentPlus/refs/heads/main/Beta.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

-- Check if a window already exists before creating another
if _G.FluentWindow then
    _G.FluentWindow:Destroy()
end

-- Create the main window
local Window = Fluent:CreateWindow({
    Title = "NEON RB " .. Fluent.Version,
    SubTitle = "By MRX",
    TabWidth = 160,
    Size = UDim2.fromOffset(500, 350),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

_G.FluentWindow = Window -- Save global reference to avoid duplicates

local Tabs = {
    Main = Window:AddTab({ Title = "Main", Icon = "home" }),
    Player = Window:AddTab({ Title = "Player", Icon = "user" }),
    Combat = Window:AddTab({ Title = "Combat", Icon = "sword" }),
    Teleport = Window:AddTab({ Title = "Teleport", Icon = "map-pin" }),
    Esp = Window:AddTab({ Title = "Esp", Icon = "eye" }),
    Credits = Window:AddTab({ Title = "Credits", Icon = "award" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

Fluent:Notify({
    Title = "Notification",
    Content = "The script has been loaded.",
    Duration = 8
})

------------------------------------------------------------------------------------
---[MAIN] CONTENT

Tabs.Main:AddParagraph({
    Title = "Created By:",
    Content = "NEON RB\nMRX"
})

Tabs.Main:AddButton({
    Title = "Read This!!",
    Description = "Very important button",
    Callback = function()
        Window:Dialog({
            Title = "NEON RB",
            Content = "The script is in BETA version and may contain bugs. If you encounter any issues, restart the script.",
            Buttons = {
                {
                    Title = "Confirm",
                    Callback = function()
                        print("Confirmed the dialog.")
                    end
                }
            }
        })
    end
})

Tabs.Main:AddParagraph({
    Title = "Join our discord server:",
    Content = "https://discord.gg/DvNZUGvdvR"
})

Tabs.Main:AddButton({
    Title = "Copy Discord Link",
    Description = "Click to copy the invite link",
    Callback = function()
        setclipboard("https://discord.gg/DvNZUGvdvR")
        Fluent:Notify({
            Title = "Copied!",
            Content = "Discord link copied to clipboard.",
            Duration = 3
        })
    end
})

local playerCount = #game.Players:GetPlayers()

Tabs.Main:AddParagraph({
    Title = "Active Users:",
    Content = "Currently: " .. playerCount .. " players"
})

-----------------------------------------------------------

local speedEnabled = false
local speedMultiplier = 3 -- Speed multiplier
local player = game.Players.LocalPlayer

local function setSpeed()
    while speedEnabled do
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.WalkSpeed = 16 * speedMultiplier
        end
        wait(0.1)
    end
end

local SpeedToggle = Tabs.Player:AddToggle("Speed", { Title = "Speed Hack", Default = false })

SpeedToggle:OnChanged(function()
    speedEnabled = SpeedToggle.Value
    if speedEnabled then
        print("Speed Hack ACTIVATED")
        task.spawn(setSpeed)
    else
        print("Speed Hack DEACTIVATED")
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.WalkSpeed = 16 -- Reset normal speed
        end
    end
end)

local staminaEnabled = false

local function infiniteStamina()
    while staminaEnabled do
        local player = game.Players.LocalPlayer
        if player and player.Character then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:SetAttribute("Energy", 100)
                humanoid:SetAttribute("Stamina", 100)
                humanoid.JumpPower = 50
                humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
            end
        end
        wait(0.05)
    end
end

--[[
=====================================================
            PLAYER TAB SIMPLIFIED
      Optimized for The Survival Game
=====================================================
--]]

--=====================================================
-- BASIC FUNCTIONS THAT WORK IN THE GAME
--=====================================================

-- Services
local VirtualUser = game:GetService("VirtualUser")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Variables for auto click
local autoClicking = false
local clickInterval = 0.15

-- Auto click function (optimized)
local function autoClick()
    while autoClicking do
        VirtualUser:Button1Down(Vector2.new(0, 0))
        task.wait(0.05)
        VirtualUser:Button1Up(Vector2.new(0, 0))
        task.wait(clickInterval)
    end
end

-- Variable for stamina
local staminaEnabled = false
local staminaConnection = nil

-- Function for infinite stamina (optimized)
local function startInfiniteStamina()
    -- Disconnect existing connection if any
    if staminaConnection then
        staminaConnection:Disconnect()
        staminaConnection = nil
    end
    
    -- Create new connection
    if staminaEnabled then
        staminaConnection = RunService.Heartbeat:Connect(function()
            if LocalPlayer.Character then
                local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    -- Set stamina attributes
                    humanoid:SetAttribute("Energy", 100)
                    humanoid:SetAttribute("Stamina", 100)
                    
                    -- Ensure jump is enabled
                    humanoid.JumpPower = 50
                    humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
                end
            end
        end)
    end
end

-- Function to stop everything
local function stopAllFunctions()
    -- Stop auto click
    autoClicking = false
    
    -- Stop infinite stamina
    staminaEnabled = false
    if staminaConnection then
        staminaConnection:Disconnect()
        staminaConnection = nil
    end
    
    -- Restore normal values
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
        LocalPlayer.Character.Humanoid.JumpPower = 50
    end
end

--=====================================================
-- SIMPLIFIED USER INTERFACE
--=====================================================

-- Main section
local MainSection = Tabs.Player:AddSection("Basic Functions")

-- Auto Click
local AutoClickToggle = Tabs.Player:AddToggle("AutoClick", { Title = "Auto Click", Default = false })

AutoClickToggle:OnChanged(function()
    autoClicking = AutoClickToggle.Value
    
    if autoClicking then
        task.spawn(autoClick)
        
        pcall(function()
            Fluent:Notify({
                Title = "Auto Click Activated",
                Content = "Automatic clicks started",
                Duration = 2
            })
        end)
    else
        pcall(function()
            Fluent:Notify({
                Title = "Auto Click Deactivated",
                Content = "Automatic clicks stopped",
                Duration = 2
            })
        end)
    end
end)

-- Auto Click Speed
local ClickSpeedSlider = Tabs.Player:AddSlider("ClickSpeed", {
    Title = "Click Speed",
    Description = "Interval between clicks (seconds)",
    Default = clickInterval,
    Min = 0.05,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        clickInterval = Value
    end
})

-- Infinite Stamina
local StaminaToggle = Tabs.Player:AddToggle("InfiniteStamina", { Title = "Infinite Stamina", Default = false })

StaminaToggle:OnChanged(function()
    staminaEnabled = StaminaToggle.Value
    startInfiniteStamina()
    
    pcall(function()
        Fluent:Notify({
            Title = staminaEnabled and "Infinite Stamina Activated" or "Infinite Stamina Deactivated",
            Content = staminaEnabled and "You will no longer get tired when running" or "Normal stamina restored",
            Duration = 2
        })
    end)
end)

-- Information section
local InfoSection = Tabs.Player:AddSection("Information")

-- Anti-cheat information
Tabs.Player:AddParagraph({
    Title = "Warning About Anti-Cheat",
    Content = "The Survival Game has an advanced anti-cheat system. Only basic functions that are not detected are included."
})

-- Emergency section
local EmergencySection = Tabs.Player:AddSection("Emergency")

-- Panic button
Tabs.Player:AddButton({
    Title = "PANIC BUTTON",
    Description = "Immediately disables all functions",
    Callback = function()
        stopAllFunctions()
        
        -- Update UI
        AutoClickToggle:Set(false)
        StaminaToggle:Set(false)
        
        pcall(function()
            Fluent:Notify({
                Title = "Functions Deactivated",
                Content = "All functions have been stopped",
                Duration = 3
            })
        end)
    end
})

-- Character reset button
Tabs.Player:AddButton({
    Title = "Reset Character",
    Description = "Resets your character in case of problems",
    Callback = function()
        pcall(function()
            stopAllFunctions()
            
            -- Update UI
            AutoClickToggle:Set(false)
            StaminaToggle:Set(false)
            
            if LocalPlayer.Character then
                LocalPlayer.Character:BreakJoints()
            end
            
            Fluent:Notify({
                Title = "Character Reset",
                Content = "Your character will reset shortly",
                Duration = 3
            })
        end)
    end
})

-- Disconnect everything on exit
game:GetService("Players").PlayerRemoving:Connect(function(plr)
    if plr == LocalPlayer then
        stopAllFunctions()
    end
end)

-------------------------------------------------------------------

local hitboxEnabled = false

local function expandHitboxes()
    while hitboxEnabled do
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                player.Character.HumanoidRootPart.Size = Vector3.new(7, 7, 7)
            end
        end
        wait(0.1)
    end
end

local HitboxToggle = Tabs.Combat:AddToggle("Hitbox", { Title = "Expand Hitbox", Default = false })

HitboxToggle:OnChanged(function()
    hitboxEnabled = HitboxToggle.Value
    if hitboxEnabled then
        print("Hitbox ACTIVATED")
        task.spawn(expandHitboxes)
    else
        print("Hitbox DEACTIVATED")
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                player.Character.HumanoidRootPart.Size = Vector3.new(2, 2, 1) -- Normal size
            end
        end
    end
end)

---------------------------

-- AUTOMATIC CROSS-PLATFORM AIMBOT (GUARANTEED ERROR-FREE VERSION)
local enabled = false
local fovSize = 100
local smoothness = 0.3
local targetPart = "Head"

-- Required global variables
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local Connection = nil

-- FOV circle
local circle = Drawing.new("Circle")
circle.Visible = false
circle.Radius = fovSize
circle.Color = Color3.fromRGB(255, 0, 0)
circle.Thickness = 1.5
circle.Filled = false
circle.Transparency = 0.7
circle.NumSides = 30

-- Single function to get target
local function getTarget()
    local closest = nil
    local maxDist = fovSize
    
    if not enabled then
        return nil
    end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild(targetPart) then
            local pos, vis = Camera:WorldToViewportPoint(player.Character[targetPart].Position)
            
            if vis then
                local dist = (Vector2.new(pos.X, pos.Y) - Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)).Magnitude
                
                if dist < maxDist then
                    maxDist = dist
                    closest = player.Character[targetPart]
                end
            end
        end
    end
    
    return closest
end

-- Main function (keeps everything in a single function)
local function updateAimbot()
    -- Remove previous connection if exists
    if Connection then
        Connection:Disconnect()
        Connection = nil
    end
    
    -- Create new connection
    Connection = RunService.RenderStepped:Connect(function()
        -- Update circle
        circle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
        circle.Radius = fovSize
        circle.Visible = enabled
        
        -- If not activated, exit
        if not enabled then
            return
        end
        
        -- Get target
        local target = getTarget()
        
        -- Aim at target
        if target then
            local targetPos = target.Position
            Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.Position, targetPos), smoothness)
        end
    end)
end

-- Clean up on disconnect
game:GetService("Players").PlayerRemoving:Connect(function(player)
    if player == LocalPlayer then
        if Connection then
            Connection:Disconnect()
        end
        circle:Remove()
    end
end)

-- UI Interface
local toggle = Tabs.Combat:AddToggle("SimpleAimbot", {
    Title = "Automatic Aimbot",
    Default = false
})

toggle:OnChanged(function()
    enabled = toggle.Value
    
    if enabled then
        updateAimbot()
        
        Fluent:Notify({
            Title = "Automatic Aimbot",
            Content = "Aimbot is activated and working",
            Duration = 3
        })
    else
        if Connection then
            Connection:Disconnect()
            Connection = nil
        end
        circle.Visible = false
    end
end)

-- Simple configurations
Tabs.Combat:AddSlider("AimbotFOV", {
    Title = "FOV Radius",
    Default = fovSize,
    Min = 30,
    Max = 300,
    Rounding = 0,
    Callback = function(Value)
        fovSize = Value
    end
})

Tabs.Combat:AddSlider("AimbotSmooth", {
    Title = "Smoothness",
    Default = smoothness * 10,
    Min = 1,
    Max = 10,
    Rounding = 1,
    Callback = function(Value)
        smoothness = Value / 10
    end
})

Tabs.Combat:AddDropdown("AimbotPart", {
    Title = "Target Part",
    Values = {"Head", "HumanoidRootPart", "Torso", "UpperTorso"},
    Default = targetPart,
    Multi = false,
    Callback = function(Value)
        targetPart = Value
    end
})

-- Start aimbot
updateAimbot()

-------------------------------------------

local insideTPEnabled = false
local followDistance = 2 -- Distance to maintain
local maxFollowDistance = 10 -- Only follow nearby players
local localPlayer = game.Players.LocalPlayer
local runService = game:GetService("RunService")

-- Function to find the closest player
local function getClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = math.huge

    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (localPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
            if distance < shortestDistance and distance <= maxFollowDistance then
                shortestDistance = distance
                closestPlayer = player
            end
        end
    end
    return closestPlayer
end

-- Follow the closest player in real time
local function followClosestPlayer()
    while insideTPEnabled do
        local targetPlayer = getClosestPlayer()
        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local targetHRP = targetPlayer.Character.HumanoidRootPart
            local localCharacter = localPlayer.Character
            
            if localCharacter and localCharacter:FindFirstChild("HumanoidRootPart") then
                local localHRP = localCharacter.HumanoidRootPart

                -- Smooth and natural displacement
                local targetPosition = targetHRP.Position - targetHRP.CFrame.LookVector * followDistance
                targetPosition = Vector3.new(targetPosition.X, targetHRP.Position.Y, targetPosition.Z)

                localHRP.CFrame = localHRP.CFrame:Lerp(CFrame.new(targetPosition, targetHRP.Position), 0.2)
            end
        else
            print("No nearby players.")
        end
        task.wait(0.02)
    end
end

-- Handle when player respawns
local function onCharacterAdded(character)
    repeat task.wait() until character:FindFirstChild("HumanoidRootPart")
    if insideTPEnabled then
        task.spawn(followClosestPlayer)
    end
end

localPlayer.CharacterAdded:Connect(onCharacterAdded)

-- Toggle in Fluent UI
local InsideTPToggle = Tabs.Combat:AddToggle("InsideTP", { Title = "Inside TP", Default = false })

InsideTPToggle:OnChanged(function()
    insideTPEnabled = InsideTPToggle.Value
    if insideTPEnabled then
        print("Inside TP ACTIVATED")
        task.spawn(followClosestPlayer)
    else
        print("Inside TP DEACTIVATED")
    end
end)


---------------------------------------------------------------------------

---------------------------------------------------------------------------
--[[
=====================================================
               SIMPLIFIED ESP SYSTEM
         Optimized version without syntax errors
=====================================================
--]]

--=====================================================
-- INITIALIZATION AND RESOURCE CLEANUP
--=====================================================

-- Clean up previous resources
if _G.NEON_ESP_LOOP then
    pcall(function() _G.NEON_ESP_LOOP:Disconnect() end)
    _G.NEON_ESP_LOOP = nil
end

if _G.NEON_ESP_OBJECTS then
    pcall(function()
        for _, obj in pairs(_G.NEON_ESP_OBJECTS) do
            for k, v in pairs(obj) do
                if typeof(v) == "table" then
                    for _, sv in pairs(v) do
                        pcall(function() 
                            if sv.Remove then 
                                sv:Remove() 
                            end 
                        end)
                    end
                elseif v and v.Remove then
                    pcall(function() v:Remove() end)
                end
            end
        end
    end)
end

-- Initialize global variables
_G.NEON_ESP_OBJECTS = {}
_G.NEON_ESP_ACTIVE = false
_G.NEON_ESP_PREVIEW = false
_G.NEON_ESP_SETTINGS = {
    BoxEnabled = false,
    NameEnabled = false,
    HealthEnabled = false,
    DistanceEnabled = false,
    TracersEnabled = false,
    MaxDistance = 1000
}

--=====================================================
-- SERVICES AND VARIABLES
--=====================================================

-- Services
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

--=====================================================
-- UTILITY FUNCTIONS
--=====================================================

-- Function to safely get screen position
local function GetScreenPosition(worldPos)
    if not worldPos then return Vector2.new(), false end
    
    local screenPos, onScreen = false, false
    pcall(function()
        screenPos, onScreen = Camera:WorldToViewportPoint(worldPos)
    end)
    
    if not onScreen or not screenPos then
        return Vector2.new(), false
    end
    
    return Vector2.new(screenPos.X, screenPos.Y), true
end

-- Function to get color by team
local function GetPlayerColor(player)
    if player.Team and player.Team == LocalPlayer.Team then
        return Color3.fromRGB(0, 255, 0) -- Green for allies
    else
        return Color3.fromRGB(255, 0, 0) -- Red for enemies
    end
end

--=====================================================
-- ESP OBJECT MANAGEMENT FUNCTIONS
--=====================================================

-- Function to create ESP object
local function CreateEspObject(player)
    if player == LocalPlayer and not _G.NEON_ESP_PREVIEW then
        return
    end
    
    local objects = {}
    
    -- Create Drawing objects with error protection
    pcall(function()
        objects.Box = Drawing.new("Square")
        objects.Box.Thickness = 2
        objects.Box.Filled = false
        objects.Box.Visible = false
        
        objects.Name = Drawing.new("Text")
        objects.Name.Center = true
        objects.Name.Outline = true
        objects.Name.Size = 14
        objects.Name.Visible = false
        
        objects.Tracer = Drawing.new("Line")
        objects.Tracer.Thickness = 1.5
        objects.Tracer.Visible = false
        
        objects.Health = Drawing.new("Square")
        objects.Health.Thickness = 1
        objects.Health.Filled = true
        objects.Health.Visible = false
        
        objects.Distance = Drawing.new("Text")
        objects.Distance.Center = true
        objects.Distance.Outline = true
        objects.Distance.Size = 13
        objects.Distance.Visible = false
    end)
    
    _G.NEON_ESP_OBJECTS[player] = objects
    return objects
end

-- Function to remove ESP object
local function RemoveEspObject(player)
    local objects = _G.NEON_ESP_OBJECTS[player]
    if objects then
        for _, obj in pairs(objects) do
            pcall(function() 
                if obj.Remove then
                    obj:Remove()
                end
            end)
        end
        _G.NEON_ESP_OBJECTS[player] = nil
    end
end

-- Function to hide ESP object
local function HideEspObject(objects)
    if not objects then return end
    
    pcall(function()
        for _, obj in pairs(objects) do
            if obj.Visible ~= nil then
                obj.Visible = false
            end
        end
    end)
end

--=====================================================
-- ESP UPDATE FUNCTIONS
--=====================================================

-- Function to update player ESP
local function UpdatePlayerESP(player)
    if not player or not player.Character or player == LocalPlayer and not _G.NEON_ESP_PREVIEW then
        return
    end
    
    -- Check required components
    local character = player.Character
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local head = character:FindFirstChild("Head")
    
    if not humanoidRootPart or not humanoid or not head then
        return
    end
    
    -- Get or create ESP object
    local objects = _G.NEON_ESP_OBJECTS[player] or CreateEspObject(player)
    if not objects then return end
    
    -- Check distance
    local distance = (Camera.CFrame.Position - humanoidRootPart.Position).Magnitude
    if distance > _G.NEON_ESP_SETTINGS.MaxDistance then
        HideEspObject(objects)
        return
    end
    
    -- Get screen positions
    local rootPos, rootOnScreen = GetScreenPosition(humanoidRootPart.Position)
    local headPos, headOnScreen = GetScreenPosition(head.Position + Vector3.new(0, 0.5, 0))
    
    if not rootOnScreen then
        HideEspObject(objects)
        return
    end
    
    -- Calculate dimensions
    local boxSize = Vector2.new(math.clamp(math.abs(headPos.Y - rootPos.Y) * 1.5, 10, 30), 
                               math.clamp(math.abs(headPos.Y - rootPos.Y) * 2, 20, 60))
    local boxPos = Vector2.new(rootPos.X - (boxSize.X / 2), rootPos.Y - (boxSize.Y / 2))
    
    -- Get color
    local color = GetPlayerColor(player)
    
    -- Update visual elements
    
    -- Box
    if _G.NEON_ESP_SETTINGS.BoxEnabled then
        objects.Box.Size = boxSize
        objects.Box.Position = boxPos
        objects.Box.Color = color
        objects.Box.Visible = true
    else
        objects.Box.Visible = false
    end
    
    -- Name
    if _G.NEON_ESP_SETTINGS.NameEnabled then
        objects.Name.Text = player.Name
        objects.Name.Position = Vector2.new(rootPos.X, boxPos.Y - 16)
        objects.Name.Color = color
        objects.Name.Visible = true
    else
        objects.Name.Visible = false
    end
    
    -- Tracer
    if _G.NEON_ESP_SETTINGS.TracersEnabled then
        objects.Tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
        objects.Tracer.To = Vector2.new(rootPos.X, rootPos.Y)
        objects.Tracer.Color = color
        objects.Tracer.Visible = true
    else
        objects.Tracer.Visible = false
    end
    
    -- Health bar
    if _G.NEON_ESP_SETTINGS.HealthEnabled and humanoid then
        local healthPercent = humanoid.Health / humanoid.MaxHealth
        local healthColor = Color3.fromRGB(
            math.floor(255 * (1 - healthPercent)),
            math.floor(255 * healthPercent),
            0
        )
        
        local healthBarPos = Vector2.new(boxPos.X - 7, boxPos.Y)
        local healthBarSize = Vector2.new(4, boxSize.Y)
        
        objects.Health.Color = healthColor
        objects.Health.Position = Vector2.new(
            healthBarPos.X,
            healthBarPos.Y + healthBarSize.Y * (1 - healthPercent)
        )
        objects.Health.Size = Vector2.new(
            healthBarSize.X,
            healthBarSize.Y * healthPercent
        )
        objects.Health.Visible = true
    else
        objects.Health.Visible = false
    end
    
    -- Distance
    if _G.NEON_ESP_SETTINGS.DistanceEnabled then
        objects.Distance.Text = math.floor(distance) .. "m"
        objects.Distance.Position = Vector2.new(rootPos.X, boxPos.Y + boxSize.Y + 3)
        objects.Distance.Color = color
        objects.Distance.Visible = true
    else
        objects.Distance.Visible = false
    end
end

-- Function to update preview mode
local function UpdatePreviewESP()
    -- Make sure local player has an ESP object
    if not _G.NEON_ESP_OBJECTS[LocalPlayer] then
        local previewObject = {}
        
        pcall(function()
            previewObject.Box = Drawing.new("Square")
            previewObject.Box.Thickness = 2
            previewObject.Box.Filled = false
            previewObject.Box.Visible = false
            
            previewObject.Name = Drawing.new("Text")
            previewObject.Name.Center = true
            previewObject.Name.Outline = true
            previewObject.Name.Size = 14
            previewObject.Name.Visible = false
            
            previewObject.Tracer = Drawing.new("Line")
            previewObject.Tracer.Thickness = 1.5
            previewObject.Tracer.Visible = false
            
            previewObject.Health = Drawing.new("Square")
            previewObject.Health.Thickness = 1
            previewObject.Health.Filled = true
            previewObject.Health.Visible = false
            
            previewObject.Distance = Drawing.new("Text")
            previewObject.Distance.Center = true
            previewObject.Distance.Outline = true
            previewObject.Distance.Size = 13
            previewObject.Distance.Visible = false
        end)
        
        _G.NEON_ESP_OBJECTS[LocalPlayer] = previewObject
    end
    
    -- Get objects for local player
    local objects = _G.NEON_ESP_OBJECTS[LocalPlayer]
    if not objects then return end
    
    -- Check if local character exists
    if not LocalPlayer.Character then
        HideEspObject(objects)
        return
    end
    
    -- Simulated positions for preview
    local rootPos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2 + 40)
    local headPos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2 - 30)
    
    -- Calculate dimensions
    local boxSize = Vector2.new(30, 70)
    local boxPos = Vector2.new(rootPos.X - (boxSize.X / 2), rootPos.Y - (boxSize.Y / 2))
    
    -- Color for preview
    local color = Color3.fromRGB(0, 255, 0) -- Green
    
    -- Update visual elements
    
    -- Box
    if _G.NEON_ESP_SETTINGS.BoxEnabled then
        objects.Box.Size = boxSize
        objects.Box.Position = boxPos
        objects.Box.Color = color
        objects.Box.Visible = true
    else
        objects.Box.Visible = false
    end
    
    -- Name
    if _G.NEON_ESP_SETTINGS.NameEnabled then
        objects.Name.Text = LocalPlayer.Name .. " (Preview)"
        objects.Name.Position = Vector2.new(rootPos.X, boxPos.Y - 16)
        objects.Name.Color = color
        objects.Name.Visible = true
    else
        objects.Name.Visible = false
    end
    
    -- Tracer
    if _G.NEON_ESP_SETTINGS.TracersEnabled then
        objects.Tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
        objects.Tracer.To = Vector2.new(rootPos.X, rootPos.Y)
        objects.Tracer.Color = color
        objects.Tracer.Visible = true
    else
        objects.Tracer.Visible = false
    end
    
    -- Health bar
    if _G.NEON_ESP_SETTINGS.HealthEnabled then
        local healthPercent = 0.75 -- 75% health for preview
        
        local healthColor = Color3.fromRGB(
            math.floor(255 * (1 - healthPercent)),
            math.floor(255 * healthPercent),
            0
        )
        
        local healthBarPos = Vector2.new(boxPos.X - 7, boxPos.Y)
        local healthBarSize = Vector2.new(4, boxSize.Y)
        
        objects.Health.Color = healthColor
        objects.Health.Position = Vector2.new(
            healthBarPos.X,
            healthBarPos.Y + healthBarSize.Y * (1 - healthPercent)
        )
        objects.Health.Size = Vector2.new(
            healthBarSize.X,
            healthBarSize.Y * healthPercent
        )
        objects.Health.Visible = true
    else
        objects.Health.Visible = false
    end
    
    -- Distance
    if _G.NEON_ESP_SETTINGS.DistanceEnabled then
        objects.Distance.Text = "0m (Preview)"
        objects.Distance.Position = Vector2.new(rootPos.X, boxPos.Y + boxSize.Y + 3)
        objects.Distance.Color = color
        objects.Distance.Visible = true
    else
        objects.Distance.Visible = false
    end
    
    -- Hide ESP for other players in preview mode
    for player, playerObjects in pairs(_G.NEON_ESP_OBJECTS) do
        if player ~= LocalPlayer then
            HideEspObject(playerObjects)
        end
    end
end

-- Function to update all ESP
local function UpdateAllESP()
    -- If ESP is deactivated, hide everything
    if not _G.NEON_ESP_ACTIVE and not _G.NEON_ESP_PREVIEW then
        for player, objects in pairs(_G.NEON_ESP_OBJECTS) do
            HideEspObject(objects)
        end
        return
    end

    -- Preview mode
    if _G.NEON_ESP_PREVIEW and not _G.NEON_ESP_ACTIVE then
        UpdatePreviewESP()
        return
    end
    
    -- Update for all players
    for _, player in ipairs(Players:GetPlayers()) do
        pcall(function() 
            UpdatePlayerESP(player) 
        end)
    end
    
    -- Clean up objects for players who left
    for player, objects in pairs(_G.NEON_ESP_OBJECTS) do
        if not Players:FindFirstChild(player.Name) then
            RemoveEspObject(player)
        end
    end
end

--=====================================================
-- ESP CONTROL FUNCTIONS
--=====================================================

-- Function to start ESP
local function StartESP()
    if _G.NEON_ESP_LOOP then return end
    
    -- Initialize objects for existing players
    for _, player in ipairs(Players:GetPlayers()) do
        if not _G.NEON_ESP_OBJECTS[player] then
            CreateEspObject(player)
        end
    end
    
    -- Connection for updates
    _G.NEON_ESP_LOOP = RunService.RenderStepped:Connect(function()
        pcall(UpdateAllESP)
    end)
    
    -- Handle new players
    Players.PlayerAdded:Connect(function(player)
        CreateEspObject(player)
    end)
    
    -- Handle players leaving
    Players.PlayerRemoving:Connect(function(player)
        RemoveEspObject(player)
    end)
end

-- Function to stop ESP
local function StopESP()
    if _G.NEON_ESP_LOOP then
        _G.NEON_ESP_LOOP:Disconnect()
        _G.NEON_ESP_LOOP = nil
    end
    
    -- Hide all objects
    for player, objects in pairs(_G.NEON_ESP_OBJECTS) do
        HideEspObject(objects)
    end
end

-- Function to reset and clean everything
local function ResetESP()
    -- Stop loop
    if _G.NEON_ESP_LOOP then
        _G.NEON_ESP_LOOP:Disconnect()
        _G.NEON_ESP_LOOP = nil
    end
    
    -- Remove all objects
    for player, objects in pairs(_G.NEON_ESP_OBJECTS) do
        RemoveEspObject(player)
    end
    
    _G.NEON_ESP_OBJECTS = {}
    
    -- Force garbage collection
    for i = 1, 3 do
        collectgarbage("collect")
    end
    
    -- Restart if active
    if _G.NEON_ESP_ACTIVE or _G.NEON_ESP_PREVIEW then
        StartESP()
    end
end

--=====================================================
-- USER INTERFACE
--=====================================================

-- Interface configuration
local MainSection = Tabs.Esp:AddSection("Main ESP")

-- Main toggle
local MasterToggle = Tabs.Esp:AddToggle("ESPMaster", {Title = "ESP Master", Default = false})
MasterToggle:OnChanged(function()
    _G.NEON_ESP_ACTIVE = MasterToggle.Value
    
    if MasterToggle.Value and not _G.NEON_ESP_LOOP then
        StartESP()
    end
    
    pcall(function()
        Fluent:Notify({
            Title = MasterToggle.Value and "ESP Activated" or "ESP Deactivated",
            Content = MasterToggle.Value and "ESP System started successfully" or "ESP System paused",
            Duration = 2
        })
    end)
end)

-- Preview mode
local PreviewToggle = Tabs.Esp:AddToggle("ESPPreview", {Title = "Preview Mode", Default = false})
PreviewToggle:OnChanged(function()
    _G.NEON_ESP_PREVIEW = PreviewToggle.Value
    
    if PreviewToggle.Value and not _G.NEON_ESP_LOOP then
        StartESP()
    end
end)

-- Elements section
local ElementsSection = Tabs.Esp:AddSection("Visual Elements")

-- Boxes
local BoxToggle = Tabs.Esp:AddToggle("BoxESP", {Title = "ESP Boxes", Default = false})
BoxToggle:OnChanged(function()
    _G.NEON_ESP_SETTINGS.BoxEnabled = BoxToggle.Value
end)

-- Names
local NameToggle = Tabs.Esp:AddToggle("NameESP", {Title = "Names", Default = false})
NameToggle:OnChanged(function()
    _G.NEON_ESP_SETTINGS.NameEnabled = NameToggle.Value
end)

-- Health bars
local HealthToggle = Tabs.Esp:AddToggle("HealthESP", {Title = "Health Bars", Default = false})
HealthToggle:OnChanged(function()
    _G.NEON_ESP_SETTINGS.HealthEnabled = HealthToggle.Value
end)

-- Distances
local DistanceToggle = Tabs.Esp:AddToggle("DistanceESP", {Title = "Distances", Default = false})
DistanceToggle:OnChanged(function()
    _G.NEON_ESP_SETTINGS.DistanceEnabled = DistanceToggle.Value
end)

-- Tracers
local TracerToggle = Tabs.Esp:AddToggle("TracerESP", {Title = "Tracers", Default = false})
TracerToggle:OnChanged(function()
    _G.NEON_ESP_SETTINGS.TracersEnabled = TracerToggle.Value
end)

-- Settings section
local AdjustmentsSection = Tabs.Esp:AddSection("Settings")

-- Maximum distance
local MaxDistanceSlider = Tabs.Esp:AddSlider("MaxDistance", {
    Title = "Maximum Distance",
    Description = "Maximum distance to show ESP",
    Default = 1000,
    Min = 100,
    Max = 2000,
    Rounding = 0,
    Callback = function(Value)
        _G.NEON_ESP_SETTINGS.MaxDistance = Value
    end
})

--=====================================================
-- MAINTENANCE FUNCTIONS
--=====================================================

-- Maintenance section
local MaintenanceSection = Tabs.Esp:AddSection("Maintenance")

-- Reset ESP
Tabs.Esp:AddButton({
    Title = "Reset ESP",
    Description = "Fixes display issues",
    Callback = function()
        ResetESP()
        pcall(function()
            Fluent:Notify({
                Title = "ESP Reset",
                Content = "The ESP system has been completely reset",
                Duration = 3
            })
        end)
    end
})

-- Force cleanup
Tabs.Esp:AddButton({
    Title = "Force Cleanup",
    Description = "Removes all persistent visual objects",
    Callback = function()
        ResetESP()
        pcall(function()
            Fluent:Notify({
                Title = "Forced Cleanup",
                Content = "All visual elements have been removed",
                Duration = 3
            })
        end)
    end
})

-- Current game mode
Tabs.Esp:AddButton({
    Title = "Optimize for Current Game",
    Description = "Automatically configures the best settings",
    Callback = function()
        -- Enable main elements
        _G.NEON_ESP_SETTINGS.BoxEnabled = true
        _G.NEON_ESP_SETTINGS.NameEnabled = true
        _G.NEON_ESP_SETTINGS.TracersEnabled = true
        _G.NEON_ESP_SETTINGS.HealthEnabled = true
        _G.NEON_ESP_SETTINGS.DistanceEnabled = true
        
        -- Update UI
        BoxToggle:Set(true)
        NameToggle:Set(true)
        TracerToggle:Set(true)
        HealthToggle:Set(true)
        DistanceToggle:Set(true)
        
        pcall(function()
            Fluent:Notify({
                Title = "Optimization Completed",
                Content = "ESP configuration has been optimized for this game",
                Duration = 3
            })
        end)
    end
})
------------------------------------------------------------------------------------
---[CREDITS] CONTENT

Tabs.Credits:AddParagraph({
    Title = "Developers:",
    Content = "Main Developer: MRX\nUI Framework: Fluent\nDiscord: https://discord.gg/DvNZUGvdvR"
})

------------------------------------------------------------------------------------

-- SaveManager and InterfaceManager configuration
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Window:SelectTab(1)

-- Load automatic configuration if available
SaveManager:LoadAutoloadConfig()
